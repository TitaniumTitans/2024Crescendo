

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>



#include <frc\smartdashboard\SendableChooser.h>


#include <gilsafe_object.h>









#include <rpygen/frc__SendableChooserBase.hpp>



namespace rpygen {


using namespace frc;





template <typename T, typename CfgBase = EmptyTrampolineCfg>
struct PyTrampolineCfg_frc__SendableChooser :


    PyTrampolineCfg_frc__SendableChooserBase<

CfgBase
>

{
    using Base = frc::SendableChooser<T>;

    
    
    using override_base_InitSendable_RTSendableBuilder = frc::SendableChooser<T>;
    
};




template <typename PyTrampolineBase, typename T, typename PyTrampolineCfg>
using PyTrampolineBase_frc__SendableChooser =

    PyTrampoline_frc__SendableChooserBase<

        PyTrampolineBase

        
        , PyTrampolineCfg
    >

;

template <typename PyTrampolineBase, typename T, typename PyTrampolineCfg>
struct PyTrampoline_frc__SendableChooser : PyTrampolineBase_frc__SendableChooser<PyTrampolineBase, T, PyTrampolineCfg> {
    using PyTrampolineBase_frc__SendableChooser<PyTrampolineBase, T, PyTrampolineCfg>::PyTrampolineBase_frc__SendableChooser;











    
    
#ifndef RPYGEN_DISABLE_InitSendable_RTSendableBuilder
    void InitSendable(wpi::SendableBuilder& builder) override {
    
    
    
    
        using LookupBase = typename PyTrampolineCfg::Base;
    
    
        using CxxCallBase = typename PyTrampolineCfg::override_base_InitSendable_RTSendableBuilder;
        PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(void), LookupBase,
            "initSendable", builder);
        return CxxCallBase::InitSendable(std::forward<decltype(builder)>(builder));
    
    
    
    }
#endif

    

    
    

    

    
};

}; // namespace rpygen







#include <pybind11/functional.h>


namespace rpygen {


using namespace frc;




template <typename T>
struct bind_frc__SendableChooser {

    

    
  
  

    

    
  using SendableChooser_Trampoline = rpygen::PyTrampoline_frc__SendableChooser<typename frc::SendableChooser<T>, T, typename rpygen::PyTrampolineCfg_frc__SendableChooser<T>>;
    static_assert(std::is_abstract<SendableChooser_Trampoline>::value == false, "frc::SendableChooser<T> " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::SendableChooser<T>, SendableChooser_Trampoline, frc::SendableChooserBase> cls_SendableChooser;

    

    
    

    py::module &m;
    std::string clsName;

bind_frc__SendableChooser(py::module &m, const char * clsName) :
    
    cls_SendableChooser(m, clsName),

  

  
  
    m(m),
    clsName(clsName)
{
    
  

}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    

  cls_SendableChooser.doc() =
    "The SendableChooser class is a useful tool for presenting a selection of\n"
"options to the SmartDashboard.\n"
"\n"
"For instance, you may wish to be able to select between multiple autonomous\n"
"modes. You can do this by putting every possible Command you want to run as\n"
"an autonomous into a SendableChooser and then put it into the SmartDashboard\n"
"to have a list of options appear on the laptop. Once autonomous starts,\n"
"simply ask the SendableChooser what the selected value is.\n"
"\n"
"@tparam T The type of values to be stored\n"
"@see SmartDashboard";

  cls_SendableChooser
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .
def
("addOption", &frc::SendableChooser<T>::AddOption,
      py::arg("name"), py::arg("object"), release_gil(), py::doc(
    "Adds the given object to the list of options.\n"
"\n"
"On the SmartDashboard on the desktop, the object will appear as the given\n"
"name.\n"
"\n"
":param name:   the name of the option\n"
":param object: the option")
  )
  
  
  
    
  .
def
("setDefaultOption", &frc::SendableChooser<T>::SetDefaultOption,
      py::arg("name"), py::arg("object"), release_gil(), py::doc(
    "Add the given object to the list of options and marks it as the default.\n"
"\n"
"Functionally, this is very close to AddOption() except that it will use\n"
"this as the default option if none other is explicitly selected.\n"
"\n"
":param name:   the name of the option\n"
":param object: the option")
  )
  
  
  
    
  .
def
("getSelected", [](frc::SendableChooser<T> * __that) -> py::object {
  auto v = __that->GetSelected();
  if (!v) {
    return py::none();
  }
  return v;
}
, py::doc(
    "Returns a copy of the selected option (a raw pointer U* if T =\n"
"std::unique_ptr<U> or a std::weak_ptr<U> if T = std::shared_ptr<U>).\n"
"\n"
"If there is none selected, it will return the default. If there is none\n"
"selected and no default, then it will return a value-initialized instance.\n"
"For integer types, this is 0. For container types like std::string, this is\n"
"an empty string.\n"
"\n"
":returns: The option selected")
  )
  
  
  
    
  .
def
("onChange", [](frc::SendableChooser<T> *self, std::function<void(T)> fn) {
  self->OnChange([fn](T v) {
    py::gil_scoped_acquire lock;
    if (v) {
      fn(v);
    } else {
      fn(py::none());
    }
  });
}
,
      py::arg("param0").none(false), py::doc(
    "Bind a listener that's called when the selected value changes.\n"
"Only one listener can be bound. Calling this function will replace the\n"
"previous listener.\n"
"\n"
":param listener: The function to call that accepts the new value")
  )
  
  
  
    
  .
def
("initSendable", &frc::SendableChooser<T>::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  



    if (set_doc) {
        cls_SendableChooser.doc() = set_doc;
    }
    if (add_doc) {
        cls_SendableChooser.doc() = py::cast<std::string>(cls_SendableChooser.doc()) + add_doc;
    }

    
}

}; // struct bind_frc__SendableChooser

}; // namespace rpygen
