

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>



#include <frc\kinematics\SwerveDriveWheelPositions.h>










#include <wpi_array_type_caster.h>


namespace rpygen {


using namespace frc;




template <size_t NumModules>
struct bind_frc__SwerveDriveWheelPositions {

    

    
  
  

    

    py::class_<typename frc::SwerveDriveWheelPositions<NumModules>> cls_SwerveDriveWheelPositions;

    

    
    

    py::module &m;
    std::string clsName;

bind_frc__SwerveDriveWheelPositions(py::module &m, const char * clsName) :
    
    cls_SwerveDriveWheelPositions(m, clsName),

  

  
  
    m(m),
    clsName(clsName)
{
    
  

}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    

  cls_SwerveDriveWheelPositions.doc() =
    "Represents the wheel positions for a swerve drive drivetrain.";

  cls_SwerveDriveWheelPositions
  
    
  .def("__eq__", [](frc::SwerveDriveWheelPositions<NumModules> &self, frc::SwerveDriveWheelPositions<NumModules> &other) {
    return self == other;
}, py::is_operator()
, py::doc(
    "Checks equality between this SwerveDriveWheelPositions and another object.\n"
"\n"
":param other: The other object.\n"
"\n"
":returns: Whether the two objects are equal.")
  )
  
  
  
    
  .def("__ne__", [](frc::SwerveDriveWheelPositions<NumModules> &self, frc::SwerveDriveWheelPositions<NumModules> &other) {
    return self != other;
}, py::is_operator()
, py::doc(
    "Checks inequality between this SwerveDriveWheelPositions and another\n"
"object.\n"
"\n"
":param other: The other object.\n"
"\n"
":returns: Whether the two objects are not equal.")
  )
  
  
  
    
  .
def
("interpolate", &frc::SwerveDriveWheelPositions<NumModules>::Interpolate,
      py::arg("endValue"), py::arg("t"), release_gil()
  )
  
  
  
    .def_readwrite("positions", &frc::SwerveDriveWheelPositions<NumModules>::positions, py::doc(
    "The distances driven by the wheels."))
  ;

  



    if (set_doc) {
        cls_SwerveDriveWheelPositions.doc() = set_doc;
    }
    if (add_doc) {
        cls_SwerveDriveWheelPositions.doc() = py::cast<std::string>(cls_SwerveDriveWheelPositions.doc()) + add_doc;
    }

    cls_SwerveDriveWheelPositions
  .def(py::init<wpi::array<SwerveModulePosition, NumModules>>(),
    py::arg("positions")
  );

}

}; // struct bind_frc__SwerveDriveWheelPositions

}; // namespace rpygen
