

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>



#include <frc\controller\ControlAffinePlantInversionFeedforward.h>










#include <pybind11/eigen.h>

#include <pybind11/functional.h>

#include <units_time_type_caster.h>


namespace rpygen {


using namespace frc;




template <int States, int Inputs>
struct bind_frc__ControlAffinePlantInversionFeedforward {

    

    
  
  
    using StateVector [[maybe_unused]] = typename frc::ControlAffinePlantInversionFeedforward<States, Inputs>::StateVector;
  
    using InputVector [[maybe_unused]] = typename frc::ControlAffinePlantInversionFeedforward<States, Inputs>::InputVector;
  

    

    py::class_<typename frc::ControlAffinePlantInversionFeedforward<States, Inputs>> cls_ControlAffinePlantInversionFeedforward;

    

    
    

    py::module &m;
    std::string clsName;

bind_frc__ControlAffinePlantInversionFeedforward(py::module &m, const char * clsName) :
    
    cls_ControlAffinePlantInversionFeedforward(m, clsName),

  

  
  
    m(m),
    clsName(clsName)
{
    
  

}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    

  cls_ControlAffinePlantInversionFeedforward.doc() =
    "Constructs a control-affine plant inversion model-based feedforward from\n"
"given model dynamics.\n"
"\n"
"If given the vector valued function as f(x, u) where x is the state\n"
"vector and u is the input vector, the B matrix(continuous input matrix)\n"
"is calculated through a NumericalJacobian. In this case f has to be\n"
"control-affine (of the form f(x) + Bu).\n"
"\n"
"The feedforward is calculated as\n"
":strong:` u_ff = B:sup:`+` (rDot - f(x)) `, where :strong:`\n"
"B:sup:`+` ` is the pseudoinverse of B.\n"
"\n"
"This feedforward does not account for a dynamic B matrix, B is either\n"
"determined or supplied when the feedforward is created and remains constant.\n"
"\n"
"For more on the underlying math, read\n"
"https://file.tavsys.net/control/controls-engineering-in-frc.pdf.\n"
"\n"
"@tparam States Number of states.\n"
"@tparam Inputs Number of inputs.";

  cls_ControlAffinePlantInversionFeedforward
  
    
  .def(py::init<std::function<StateVector (const StateVector&, const InputVector&)>, units::second_t>(),
      py::arg("f").none(false), py::arg("dt"), release_gil(), py::doc(
    "Constructs a feedforward with given model dynamics as a function\n"
"of state and input.\n"
"\n"
":param f:  A vector-valued function of x, the state, and\n"
"           u, the input, that returns the derivative of\n"
"           the state vector. HAS to be control-affine\n"
"           (of the form f(x) + Bu).\n"
":param dt: The timestep between calls of calculate().")
  )
  
  
  
    
  .def(py::init<std::function<StateVector (const StateVector&)>, const Matrixd<States, Inputs>&, units::second_t>(),
      py::arg("f").none(false), py::arg("B"), py::arg("dt"), release_gil()
    , py::keep_alive<1, 3>(), py::doc(
    "Constructs a feedforward with given model dynamics as a function of state,\n"
"and the plant's B matrix(continuous input matrix).\n"
"\n"
":param f:  A vector-valued function of x, the state,\n"
"           that returns the derivative of the state vector.\n"
":param B:  Continuous input matrix of the plant being controlled.\n"
":param dt: The timestep between calls of calculate().")
  )
  
  
  
    
  .
def
("uff", static_cast<const InputVector&(frc::ControlAffinePlantInversionFeedforward<States, Inputs>::*)() const>(
        &frc::ControlAffinePlantInversionFeedforward<States, Inputs>::Uff), release_gil(), py::doc(
    "Returns the previously calculated feedforward as an input vector.\n"
"\n"
":returns: The calculated feedforward.")
  )
  
  
  
    
  .
def
("uff", static_cast<double(frc::ControlAffinePlantInversionFeedforward<States, Inputs>::*)(int) const>(
        &frc::ControlAffinePlantInversionFeedforward<States, Inputs>::Uff),
      py::arg("i"), release_gil(), py::doc(
    "Returns an element of the previously calculated feedforward.\n"
"\n"
":param i: Row of uff.\n"
"\n"
":returns: The row of the calculated feedforward.")
  )
  
  
  
    
  .
def
("R", static_cast<const StateVector&(frc::ControlAffinePlantInversionFeedforward<States, Inputs>::*)() const>(
        &frc::ControlAffinePlantInversionFeedforward<States, Inputs>::R), release_gil(), py::doc(
    "Returns the current reference vector r.\n"
"\n"
":returns: The current reference vector.")
  )
  
  
  
    
  .
def
("R", static_cast<double(frc::ControlAffinePlantInversionFeedforward<States, Inputs>::*)(int) const>(
        &frc::ControlAffinePlantInversionFeedforward<States, Inputs>::R),
      py::arg("i"), release_gil(), py::doc(
    "Returns an element of the reference vector r.\n"
"\n"
":param i: Row of r.\n"
"\n"
":returns: The row of the current reference vector.")
  )
  
  
  
    
  .
def
("reset", static_cast<void(frc::ControlAffinePlantInversionFeedforward<States, Inputs>::*)(const StateVector&)>(
        &frc::ControlAffinePlantInversionFeedforward<States, Inputs>::Reset),
      py::arg("initialState"), release_gil(), py::doc(
    "Resets the feedforward with a specified initial state vector.\n"
"\n"
":param initialState: The initial state vector.")
  )
  
  
  
    
  .
def
("reset", static_cast<void(frc::ControlAffinePlantInversionFeedforward<States, Inputs>::*)()>(
        &frc::ControlAffinePlantInversionFeedforward<States, Inputs>::Reset), release_gil(), py::doc(
    "Resets the feedforward with a zero initial state vector.")
  )
  
  
  
    
  .
def
("calculate", static_cast<InputVector(frc::ControlAffinePlantInversionFeedforward<States, Inputs>::*)(const StateVector&)>(
        &frc::ControlAffinePlantInversionFeedforward<States, Inputs>::Calculate),
      py::arg("nextR"), release_gil(), py::doc(
    "Calculate the feedforward with only the desired\n"
"future reference. This uses the internally stored \"current\"\n"
"reference.\n"
"\n"
"If this method is used the initial state of the system is the one set using\n"
"Reset(const StateVector&). If the initial state is not\n"
"set it defaults to a zero vector.\n"
"\n"
":param nextR: The reference state of the future timestep (k + dt).\n"
"\n"
":returns: The calculated feedforward.")
  )
  
  
  
    
  .
def
("calculate", static_cast<InputVector(frc::ControlAffinePlantInversionFeedforward<States, Inputs>::*)(const StateVector&, const StateVector&)>(
        &frc::ControlAffinePlantInversionFeedforward<States, Inputs>::Calculate),
      py::arg("r"), py::arg("nextR"), release_gil(), py::doc(
    "Calculate the feedforward with current and future reference vectors.\n"
"\n"
":param r:     The reference state of the current timestep (k).\n"
":param nextR: The reference state of the future timestep (k + dt).\n"
"\n"
":returns: The calculated feedforward.")
  )
  
  
  ;

  



    if (set_doc) {
        cls_ControlAffinePlantInversionFeedforward.doc() = set_doc;
    }
    if (add_doc) {
        cls_ControlAffinePlantInversionFeedforward.doc() = py::cast<std::string>(cls_ControlAffinePlantInversionFeedforward.doc()) + add_doc;
    }

    
}

}; // struct bind_frc__ControlAffinePlantInversionFeedforward

}; // namespace rpygen
