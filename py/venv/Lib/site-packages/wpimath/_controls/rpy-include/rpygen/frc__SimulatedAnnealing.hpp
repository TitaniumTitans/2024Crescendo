

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>



#include <frc\optimization\SimulatedAnnealing.h>


#include <gilsafe_object.h>









#include <pybind11/functional.h>


namespace rpygen {


using namespace frc;




template <typename State>
struct bind_frc__SimulatedAnnealing {

    

    
  
  

    

    py::class_<typename frc::SimulatedAnnealing<State>> cls_SimulatedAnnealing;

    

    
    

    py::module &m;
    std::string clsName;

bind_frc__SimulatedAnnealing(py::module &m, const char * clsName) :
    
    cls_SimulatedAnnealing(m, clsName),

  

  
  
    m(m),
    clsName(clsName)
{
    
  

}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    

  cls_SimulatedAnnealing.doc() =
    "An implementation of the Simulated Annealing stochastic nonlinear\n"
"optimization method.\n"
"\n"
"Solving optimization problems involves tweaking decision variables to try to\n"
"minimize some cost function. Simulated annealing is good for solving\n"
"optimization problems with many local minima and a very large search space\n"
"(itâ€™s a heuristic solver rather than an exact solver like, say, SQP or\n"
"interior-point method). Simulated annealing is a popular choice for solving\n"
"the traveling salesman problem (see TravelingSalesman).\n"
"\n"
"@see <a\n"
"href=\"https://en.wikipedia.org/wiki/Simulated_annealing\">https://en.wikipedia.org/wiki/Simulated_annealing</a>\n"
"@tparam State The type of the state to optimize.";

  cls_SimulatedAnnealing
  
    
  .def(py::init<double, std::function<State (const State&)>, std::function<double (const State&)>>(),
      py::arg("initialTemperature"), py::arg("neighbor").none(false), py::arg("cost").none(false), release_gil(), py::doc(
    "Constructor for Simulated Annealing that can be used for the same functions\n"
"but with different initial states.\n"
"\n"
":param initialTemperature: The initial temperature. Higher temperatures make\n"
"                           it more likely a worse state will be accepted during iteration, helping\n"
"                           to avoid local minima. The temperature is decreased over time.\n"
":param neighbor:           Function that generates a random neighbor of the current\n"
"                           state.\n"
":param cost:               Function that returns the scalar cost of a state.")
  )
  
  
  
    
  .
def
("solve", &frc::SimulatedAnnealing<State>::Solve,
      py::arg("initialGuess"), py::arg("iterations"), release_gil(), py::doc(
    "Runs the Simulated Annealing algorithm.\n"
"\n"
":param initialGuess: The initial state.\n"
":param iterations:   Number of iterations to run the solver.\n"
"\n"
":returns: The optimized state.")
  )
  
  
  ;

  



    if (set_doc) {
        cls_SimulatedAnnealing.doc() = set_doc;
    }
    if (add_doc) {
        cls_SimulatedAnnealing.doc() = py::cast<std::string>(cls_SimulatedAnnealing.doc()) + add_doc;
    }

    
}

}; // struct bind_frc__SimulatedAnnealing

}; // namespace rpygen
