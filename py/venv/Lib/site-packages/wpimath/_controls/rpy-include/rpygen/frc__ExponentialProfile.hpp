

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>



#include <frc\trajectory\ExponentialProfile.h>










#include <units_compound_type_caster.h>

#include <units_length_type_caster.h>

#include <units_time_type_caster.h>

#include <units_velocity_type_caster.h>

#include <units_voltage_type_caster.h>


namespace rpygen {


using namespace frc;




template <typename Distance, typename Input>
struct bind_frc__ExponentialProfile {

    

    
  using ProfileTiming [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::ProfileTiming;
  
  using Constraints [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::Constraints;
  
  using State [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::State;
  
  
  
    using Distance_t [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::Distance_t;
  
    using Velocity [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::Velocity;
  
    using Velocity_t [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::Velocity_t;
  
    using Acceleration [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::Acceleration;
  
    using Input_t [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::Input_t;
  
    using A_t [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::A_t;
  
    using B_t [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::B_t;
  
    using KV [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::KV;
  
    using kV_t [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::kV_t;
  
    using KA [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::KA;
  
    using kA_t [[maybe_unused]] = typename frc::ExponentialProfile<Distance, Input>::kA_t;
  

    

    py::class_<typename frc::ExponentialProfile<Distance, Input>> cls_ExponentialProfile;

    

    
    
    py::class_<typename frc::ExponentialProfile<Distance, Input>::ProfileTiming> cls_ProfileTiming;

    

    
    
    
    py::class_<typename frc::ExponentialProfile<Distance, Input>::Constraints> cls_Constraints;

    

    
    
    
    py::class_<typename frc::ExponentialProfile<Distance, Input>::State> cls_State;

    

    
    
    

    py::module &m;
    std::string clsName;

bind_frc__ExponentialProfile(py::module &m, const char * clsName) :
    
    cls_ExponentialProfile(m, clsName),

  

  
  
    cls_ProfileTiming(cls_ExponentialProfile, "ProfileTiming"),

  

  
  
  
    cls_Constraints(cls_ExponentialProfile, "Constraints"),

  

  
  
  
    cls_State(cls_ExponentialProfile, "State"),

  

  
  
  
    m(m),
    clsName(clsName)
{
    
  

}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    

  cls_ExponentialProfile.doc() =
    "A Exponential-shaped velocity profile.\n"
"\n"
"While this class can be used for a profiled movement from start to finish,\n"
"the intended usage is to filter a reference's dynamics based on\n"
"ExponentialProfile velocity constraints. To compute the reference obeying\n"
"this constraint, do the following.\n"
"\n"
"Initialization:\n"
"@code{.cpp}\n"
"ExponentialProfile::Constraints constraints{kMaxV, kV, kA};\n"
"State previousProfiledReference = {initialReference, 0_mps};\n"
"\n"
"Run on update:\n"
"@code{.cpp}\n"
"previousProfiledReference = profile.Calculate(timeSincePreviousUpdate,\n"
"previousProfiledReference, unprofiledReference);\n"
"\n"
"where `unprofiledReference` is free to change between calls. Note that when\n"
"the unprofiled reference is within the constraints, `Calculate()` returns the\n"
"unprofiled reference unchanged.\n"
"\n"
"Otherwise, a timer can be started to provide monotonic values for\n"
"`Calculate()` and to determine when the profile has completed via\n"
"`IsFinished()`.";

  cls_ExponentialProfile
  
    
  .def(py::init<Constraints>(),
      py::arg("constraints"), release_gil(), py::doc(
    "Construct a ExponentialProfile.\n"
"\n"
":param constraints: The constraints on the profile, like maximum input.")
  )
  
  
  
    
  .
def
("calculate", &frc::ExponentialProfile<Distance, Input>::Calculate,
      py::arg("t"), py::arg("current"), py::arg("goal"), release_gil(), py::doc(
    "Calculate the correct position and velocity for the profile at a time t\n"
"where the current state is at time t = 0.")
  )
  
  
  
    
  .
def
("calculateInflectionPoint", static_cast<State(frc::ExponentialProfile<Distance, Input>::*)(const State&, const State&) const>(
        &frc::ExponentialProfile<Distance, Input>::CalculateInflectionPoint),
      py::arg("current"), py::arg("goal"), release_gil(), py::doc(
    "Calculate the point after which the fastest way to reach the goal state is\n"
"to apply input in the opposite direction.")
  )
  
  
  
    
  .
def
("timeLeftUntil", &frc::ExponentialProfile<Distance, Input>::TimeLeftUntil,
      py::arg("current"), py::arg("goal"), release_gil(), py::doc(
    "Calculate the time it will take for this profile to reach the goal state.")
  )
  
  
  
    
  .
def
("calculateProfileTiming", static_cast<ProfileTiming(frc::ExponentialProfile<Distance, Input>::*)(const State&, const State&) const>(
        &frc::ExponentialProfile<Distance, Input>::CalculateProfileTiming),
      py::arg("current"), py::arg("goal"), release_gil(), py::doc(
    "Calculate the time it will take for this profile to reach the inflection\n"
"point, and the time it will take for this profile to reach the goal state.")
  )
  
  
  ;

  


  

  cls_ProfileTiming.doc() =
    "Profile timing.";

  cls_ProfileTiming
  
    .def(py::init<>(), release_gil())
  
    
  .
def
("isFinished", &frc::ExponentialProfile<Distance, Input>::ProfileTiming::IsFinished,
      py::arg("t"), release_gil(), py::doc(
    "Decides if the profile is finished by time t.\n"
"\n"
":param t: The time since the beginning of the profile.\n"
"\n"
":returns: if the profile is finished at time t.")
  )
  
  
  
    .def_readonly("inflectionTime", &frc::ExponentialProfile<Distance, Input>::ProfileTiming::inflectionTime, py::doc(
    "Profile inflection time."))
  
    .def_readonly("totalTime", &frc::ExponentialProfile<Distance, Input>::ProfileTiming::totalTime, py::doc(
    "Total profile time."))
  ;

  


  
  

  cls_Constraints.doc() =
    "Profile constraints.";

  cls_Constraints
  
    
  .
def
("maxVelocity", &frc::ExponentialProfile<Distance, Input>::Constraints::MaxVelocity, release_gil(), py::doc(
    "Computes the max achievable velocity for an Exponential Profile.\n"
"\n"
":returns: The seady-state velocity achieved by this profile.")
  )
  
  
  
    .def_readonly("maxInput", &frc::ExponentialProfile<Distance, Input>::Constraints::maxInput, py::doc(
    "Maximum unsigned input voltage."))
  
    .def_readonly("A", &frc::ExponentialProfile<Distance, Input>::Constraints::A, py::doc(
    "The State-Space 1x1 system matrix."))
  
    .def_readonly("B", &frc::ExponentialProfile<Distance, Input>::Constraints::B, py::doc(
    "The State-Space 1x1 input matrix."))
  .def_static("fromStateSpace", [](Input_t maxInput, A_t a, B_t b) {
    return typename frc::ExponentialProfile<Distance, Input>::Constraints(maxInput, a, b);
  }, py::arg("maxInput"), py::arg("a"), py::arg("b"))
.def_static("fromCharacteristics", [](Input_t maxInput, kV_t kv, kA_t ka) {
    return typename frc::ExponentialProfile<Distance, Input>::Constraints(maxInput, kv, ka);
  }, py::arg("maxInput"), py::arg("kV"), py::arg("kA"))
;

  


  
  

  cls_State.doc() =
    "Profile state.";

  cls_State
  
    
  .def(py::self == py::self
  )
  
  
  
    .def_readonly("position", &frc::ExponentialProfile<Distance, Input>::State::position, py::doc(
    "The position at this state."))
  
    .def_readonly("velocity", &frc::ExponentialProfile<Distance, Input>::State::velocity, py::doc(
    "The velocity at this state."))
  .def(py::init<Distance_t, Velocity_t>())
;

  


  

    if (set_doc) {
        cls_ExponentialProfile.doc() = set_doc;
    }
    if (add_doc) {
        cls_ExponentialProfile.doc() = py::cast<std::string>(cls_ExponentialProfile.doc()) + add_doc;
    }

    
}

}; // struct bind_frc__ExponentialProfile

}; // namespace rpygen
