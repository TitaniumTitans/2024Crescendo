

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>



#include <networktables\StructArrayTopic.h>










#include <pybind11/stl.h>

#include <wpi_json_type_caster.h>

#include <wpi_span_type_caster.h>

#include <wpystruct.h>


namespace rpygen {


using namespace nt;




template <typename T, typename I>
struct bind_nt__StructArrayTopic {

    

    
  
  
    using SubscriberType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::SubscriberType;
  
    using PublisherType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::PublisherType;
  
    using EntryType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::EntryType;
  
    using ValueType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::TimestampedValueType;
  

    

    py::class_<typename nt::StructArrayTopic<T, I>, nt::Topic> cls_StructArrayTopic;

    

    
    

    py::module &m;
    std::string clsName;

bind_nt__StructArrayTopic(py::module &m, const char * clsName) :
    
    cls_StructArrayTopic(m, clsName, py::is_final()),

  

  
  
    m(m),
    clsName(clsName)
{
    
  

}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    

  cls_StructArrayTopic.doc() =
    "NetworkTables struct-encoded value array topic.";

  cls_StructArrayTopic
  
    
  .
def
("subscribe", static_cast<SubscriberType(nt::StructArrayTopic<T, I>::*)(std::span<const T>, const PubSubOptions&)>(
        &nt::StructArrayTopic<T, I>::Subscribe),
      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new subscriber to the topic.\n"
"\n"
"The subscriber is only active as long as the returned object\n"
"is not destroyed.\n"
"\n"
".. note:: Subscribers that do not match the published data type do not return\n"
"   any values. To determine if the data type matches, use the appropriate\n"
"   Topic functions.\n"
"\n"
":param defaultValue: default value used when a default is not provided to a\n"
"                     getter function\n"
":param options:      subscribe options\n"
"\n"
":returns: subscriber")
  )
  
  
  
    
  .
def
("publish", &nt::StructArrayTopic<T, I>::Publish,
      py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new publisher to the topic.\n"
"\n"
"The publisher is only active as long as the returned object\n"
"is not destroyed.\n"
"\n"
".. note:: It is not possible to publish two different data types to the same\n"
"   topic. Conflicts between publishers are typically resolved by the\n"
"   server on a first-come, first-served basis. Any published values that\n"
"   do not match the topic's data type are dropped (ignored). To determine\n"
"   if the data type matches, use the appropriate Topic functions.\n"
"\n"
":param options: publish options\n"
"\n"
":returns: publisher")
  )
  
  
  
    
  .
def
("publishEx", &nt::StructArrayTopic<T, I>::PublishEx,
      py::arg("properties"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new publisher to the topic, with type string and initial\n"
"properties.\n"
"\n"
"The publisher is only active as long as the returned object\n"
"is not destroyed.\n"
"\n"
".. note:: It is not possible to publish two different data types to the same\n"
"   topic. Conflicts between publishers are typically resolved by the\n"
"   server on a first-come, first-served basis. Any published values that\n"
"   do not match the topic's data type are dropped (ignored). To determine\n"
"   if the data type matches, use the appropriate Topic functions.\n"
"\n"
":param properties: JSON properties\n"
":param options:    publish options\n"
"\n"
":returns: publisher")
  )
  
  
  
    
  .
def
("getEntry", static_cast<EntryType(nt::StructArrayTopic<T, I>::*)(std::span<const T>, const PubSubOptions&)>(
        &nt::StructArrayTopic<T, I>::GetEntry),
      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new entry for the topic.\n"
"\n"
"Entries act as a combination of a subscriber and a weak publisher. The\n"
"subscriber is active as long as the entry is not destroyed. The publisher\n"
"is created when the entry is first written to, and remains active until\n"
"either Unpublish() is called or the entry is destroyed.\n"
"\n"
".. note:: It is not possible to use two different data types with the same\n"
"   topic. Conflicts between publishers are typically resolved by the\n"
"   server on a first-come, first-served basis. Any published values that\n"
"   do not match the topic's data type are dropped (ignored), and the entry\n"
"   will show no new values if the data type does not match. To determine\n"
"   if the data type matches, use the appropriate Topic functions.\n"
"\n"
":param defaultValue: default value used when a default is not provided to a\n"
"                     getter function\n"
":param options:      publish and/or subscribe options\n"
"\n"
":returns: entry")
  )
  
  
  .def("close", [](nt::StructArrayTopic<T, I> *self) {
  py::gil_scoped_release release;
  *self = nt::StructArrayTopic<T, I>();
}, py::doc("Destroys the topic"))
.def("__enter__", [](nt::StructArrayTopic<T, I> *self) {
  return self;
})
.def("__exit__", [](nt::StructArrayTopic<T, I> *self, py::args args) {
  py::gil_scoped_release release;
  *self = nt::StructArrayTopic<T, I>();
})
;

  



    if (set_doc) {
        cls_StructArrayTopic.doc() = set_doc;
    }
    if (add_doc) {
        cls_StructArrayTopic.doc() = py::cast<std::string>(cls_StructArrayTopic.doc()) + add_doc;
    }

    
}

}; // struct bind_nt__StructArrayTopic

}; // namespace rpygen
