

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>



#include <ntcore_cpp_types.h>


#include <src/nt_type_caster.h>









#include <pybind11/stl.h>

#include <wpi_span_type_caster.h>

#include <wpystruct.h>


namespace rpygen {


using namespace nt;




template <typename T>
struct bind_nt__Timestamped {

    

    
  
  

    

    py::class_<typename nt::Timestamped<T>> cls_Timestamped;

    

    
    

    py::module &m;
    std::string clsName;

bind_nt__Timestamped(py::module &m, const char * clsName) :
    
    cls_Timestamped(m, clsName),

  

  
  
    m(m),
    clsName(clsName)
{
    
  

}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    

  cls_Timestamped.doc() =
    "Timestamped value.\n"
"@ingroup ntcore_cpp_handle_api";

  cls_Timestamped
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .def(py::init<int64_t, int64_t, T>(),
      py::arg("time"), py::arg("serverTime"), py::arg("value"), release_gil()
  )
  
  
  
    .def_readwrite("time", &nt::Timestamped<T>::time, py::doc(
    "Time in local time base."))
  
    .def_readwrite("serverTime", &nt::Timestamped<T>::serverTime, py::doc(
    "Time in server time base.  May be 0 or 1 for locally set values."))
  
    .def_readwrite("value", &nt::Timestamped<T>::value, py::doc(
    "Value."))
  ;
// capture class name by value
auto clsname = clsName;
cls_Timestamped.def("__repr__", [clsname](const Timestamped<T>& self) -> py::str {
  return py::str("{}(time={}, serverTime={}, value={!r})")
    .format(clsname, self.time, self.serverTime, self.value);
})
;

  



    if (set_doc) {
        cls_Timestamped.doc() = set_doc;
    }
    if (add_doc) {
        cls_Timestamped.doc() = py::cast<std::string>(cls_Timestamped.doc()) + add_doc;
    }

    
}

}; // struct bind_nt__Timestamped

}; // namespace rpygen
