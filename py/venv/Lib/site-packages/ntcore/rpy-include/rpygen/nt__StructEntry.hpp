

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>



#include <networktables\StructTopic.h>










#include <pybind11/stl.h>

#include <wpi_json_type_caster.h>

#include <wpystruct.h>


namespace rpygen {


using namespace nt;




template <typename T, typename I>
struct bind_nt__StructEntry {

    

    
  
  
    using SubscriberType [[maybe_unused]] = typename nt::StructEntry<T, I>::SubscriberType;
  
    using PublisherType [[maybe_unused]] = typename nt::StructEntry<T, I>::PublisherType;
  
    using TopicType [[maybe_unused]] = typename nt::StructEntry<T, I>::TopicType;
  
    using ValueType [[maybe_unused]] = typename nt::StructEntry<T, I>::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::StructEntry<T, I>::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::StructEntry<T, I>::TimestampedValueType;
  

    

    py::class_<typename nt::StructEntry<T, I>, nt::StructSubscriber<T, I>, nt::StructPublisher<T, I>> cls_StructEntry;

    

    
    

    py::module &m;
    std::string clsName;

bind_nt__StructEntry(py::module &m, const char * clsName) :
    
    cls_StructEntry(m, clsName, py::is_final()),

  

  
  
    m(m),
    clsName(clsName)
{
    
  

}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    

  cls_StructEntry.doc() =
    "NetworkTables struct-encoded value entry.\n"
"\n"
".. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.";

  cls_StructEntry
  
    
  .
def
("getTopic", &nt::StructEntry<T, I>::GetTopic, release_gil(), py::doc(
    "Get the corresponding topic.\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("unpublish", &nt::StructEntry<T, I>::Unpublish, release_gil(), py::doc(
    "Stops publishing the entry if it's published.")
  )
  
  
  .def("close", [](nt::StructEntry<T, I> *self) {
  py::gil_scoped_release release;
  *self = nt::StructEntry<T, I>();
}, py::doc("Destroys the entry"))
.def("__enter__", [](nt::StructEntry<T, I> *self) {
  return self;
})
.def("__exit__", [](nt::StructEntry<T, I> *self, py::args args) {
  py::gil_scoped_release release;
  *self = nt::StructEntry<T, I>();
})
;

  



    if (set_doc) {
        cls_StructEntry.doc() = set_doc;
    }
    if (add_doc) {
        cls_StructEntry.doc() = py::cast<std::string>(cls_StructEntry.doc()) + add_doc;
    }

    
}

}; // struct bind_nt__StructEntry

}; // namespace rpygen
