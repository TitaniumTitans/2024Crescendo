

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>



#include <networktables\StructTopic.h>










#include <rpygen/nt__Subscriber.hpp>



namespace rpygen {


using namespace nt;





template <typename T, typename I, typename CfgBase = EmptyTrampolineCfg>
struct PyTrampolineCfg_nt__StructSubscriber :


    PyTrampolineCfg_nt__Subscriber<

CfgBase
>

{
    using Base = nt::StructSubscriber<T, I>;

    
    
};




template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
using PyTrampolineBase_nt__StructSubscriber =

    PyTrampoline_nt__Subscriber<

        PyTrampolineBase

        
        , PyTrampolineCfg
    >

;

template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
struct PyTrampoline_nt__StructSubscriber : PyTrampolineBase_nt__StructSubscriber<PyTrampolineBase, T, I, PyTrampolineCfg> {
    using PyTrampolineBase_nt__StructSubscriber<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_nt__StructSubscriber;






    using TopicType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TopicType;

    using ValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ValueType;

    using ParamType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ParamType;

    using TimestampedValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TimestampedValueType;






    
    

    
    

    

    
};

}; // namespace rpygen







#include <pybind11/stl.h>

#include <wpi_json_type_caster.h>

#include <wpystruct.h>


namespace rpygen {


using namespace nt;




template <typename T, typename I>
struct bind_nt__StructSubscriber {

    

    
  
  
    using TopicType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TopicType;
  
    using ValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TimestampedValueType;
  

    

    
  using StructSubscriber_Trampoline = rpygen::PyTrampoline_nt__StructSubscriber<typename nt::StructSubscriber<T, I>, T, I, typename rpygen::PyTrampolineCfg_nt__StructSubscriber<T, I>>;
    static_assert(std::is_abstract<StructSubscriber_Trampoline>::value == false, "nt::StructSubscriber<T, I> " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename nt::StructSubscriber<T, I>, StructSubscriber_Trampoline, nt::Subscriber> cls_StructSubscriber;

    

    
    

    py::module &m;
    std::string clsName;

bind_nt__StructSubscriber(py::module &m, const char * clsName) :
    
    cls_StructSubscriber(m, clsName),

  

  
  
    m(m),
    clsName(clsName)
{
    
  

}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    

  cls_StructSubscriber.doc() =
    "NetworkTables struct-encoded value subscriber.";

  cls_StructSubscriber
  
    
  .
def
("get", static_cast<ValueType(nt::StructSubscriber<T, I>::*)() const>(
        &nt::StructSubscriber<T, I>::Get), release_gil(), py::doc(
    "Get the last published value.\n"
"If no value has been published or the value cannot be unpacked, returns the\n"
"stored default value.\n"
"\n"
":returns: value")
  )
  
  
  
    
  .
def
("get", static_cast<ValueType(nt::StructSubscriber<T, I>::*)(const T&) const>(
        &nt::StructSubscriber<T, I>::Get),
      py::arg("defaultValue"), release_gil(), py::doc(
    "Get the last published value.\n"
"If no value has been published or the value cannot be unpacked, returns the\n"
"passed defaultValue.\n"
"\n"
":param defaultValue: default value to return if no value has been published\n"
"\n"
":returns: value")
  )
  
  
  
    
  .
def
("getAtomic", static_cast<TimestampedValueType(nt::StructSubscriber<T, I>::*)() const>(
        &nt::StructSubscriber<T, I>::GetAtomic), release_gil(), py::doc(
    "Get the last published value along with its timestamp\n"
"If no value has been published or the value cannot be unpacked, returns the\n"
"stored default value and a timestamp of 0.\n"
"\n"
":returns: timestamped value")
  )
  
  
  
    
  .
def
("getAtomic", static_cast<TimestampedValueType(nt::StructSubscriber<T, I>::*)(const T&) const>(
        &nt::StructSubscriber<T, I>::GetAtomic),
      py::arg("defaultValue"), release_gil(), py::doc(
    "Get the last published value along with its timestamp.\n"
"If no value has been published or the value cannot be unpacked, returns the\n"
"passed defaultValue and a timestamp of 0.\n"
"\n"
":param defaultValue: default value to return if no value has been published\n"
"\n"
":returns: timestamped value")
  )
  
  
  
    
  .
def
("readQueue", &nt::StructSubscriber<T, I>::ReadQueue, release_gil(), py::doc(
    "Get an array of all valid value changes since the last call to ReadQueue.\n"
"Also provides a timestamp for each value. Values that cannot be unpacked\n"
"are dropped.\n"
"\n"
".. note:: The \"poll storage\" subscribe option can be used to set the queue\n"
"   depth.\n"
"\n"
":returns: Array of timestamped values; empty array if no valid new changes\n"
"          have been published since the previous call.")
  )
  
  
  
    
  .
def
("getTopic", &nt::StructSubscriber<T, I>::GetTopic, release_gil(), py::doc(
    "Get the corresponding topic.\n"
"\n"
":returns: Topic")
  )
  
  
  .def("close", [](nt::StructSubscriber<T, I> *self) {
  py::gil_scoped_release release;
  *self = nt::StructSubscriber<T, I>();
}, py::doc("Destroys the subscriber"))
.def("__enter__", [](nt::StructSubscriber<T, I> *self) {
  return self;
})
.def("__exit__", [](nt::StructSubscriber<T, I> *self, py::args args) {
  py::gil_scoped_release release;
  *self = nt::StructSubscriber<T, I>();
})
;

  



    if (set_doc) {
        cls_StructSubscriber.doc() = set_doc;
    }
    if (add_doc) {
        cls_StructSubscriber.doc() = py::cast<std::string>(cls_StructSubscriber.doc()) + add_doc;
    }

    
}

}; // struct bind_nt__StructSubscriber

}; // namespace rpygen
