

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>



#include <networktables\StructArrayTopic.h>










#include <rpygen/nt__Subscriber.hpp>



namespace rpygen {


using namespace nt;





template <typename T, typename I, typename CfgBase = EmptyTrampolineCfg>
struct PyTrampolineCfg_nt__StructArraySubscriber :


    PyTrampolineCfg_nt__Subscriber<

CfgBase
>

{
    using Base = nt::StructArraySubscriber<T, I>;

    
    
};




template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
using PyTrampolineBase_nt__StructArraySubscriber =

    PyTrampoline_nt__Subscriber<

        PyTrampolineBase

        
        , PyTrampolineCfg
    >

;

template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
struct PyTrampoline_nt__StructArraySubscriber : PyTrampolineBase_nt__StructArraySubscriber<PyTrampolineBase, T, I, PyTrampolineCfg> {
    using PyTrampolineBase_nt__StructArraySubscriber<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_nt__StructArraySubscriber;






    using TopicType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TopicType;

    using ValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ValueType;

    using ParamType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ParamType;

    using TimestampedValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TimestampedValueType;






    
    

    
    

    

    
};

}; // namespace rpygen







#include <pybind11/stl.h>

#include <wpi_json_type_caster.h>

#include <wpi_span_type_caster.h>

#include <wpystruct.h>


namespace rpygen {


using namespace nt;




template <typename T, typename I>
struct bind_nt__StructArraySubscriber {

    

    
  
  
    using TopicType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TopicType;
  
    using ValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TimestampedValueType;
  

    

    
  using StructArraySubscriber_Trampoline = rpygen::PyTrampoline_nt__StructArraySubscriber<typename nt::StructArraySubscriber<T, I>, T, I, typename rpygen::PyTrampolineCfg_nt__StructArraySubscriber<T, I>>;
    static_assert(std::is_abstract<StructArraySubscriber_Trampoline>::value == false, "nt::StructArraySubscriber<T, I> " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename nt::StructArraySubscriber<T, I>, StructArraySubscriber_Trampoline, nt::Subscriber> cls_StructArraySubscriber;

    

    
    

    py::module &m;
    std::string clsName;

bind_nt__StructArraySubscriber(py::module &m, const char * clsName) :
    
    cls_StructArraySubscriber(m, clsName),

  

  
  
    m(m),
    clsName(clsName)
{
    
  

}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    

  cls_StructArraySubscriber.doc() =
    "NetworkTables struct-encoded value array subscriber.";

  cls_StructArraySubscriber
  
    
  .
def
("get", static_cast<ValueType(nt::StructArraySubscriber<T, I>::*)() const>(
        &nt::StructArraySubscriber<T, I>::Get), release_gil(), py::doc(
    "Get the last published value.\n"
"If no value has been published or the value cannot be unpacked, returns the\n"
"stored default value.\n"
"\n"
":returns: value")
  )
  
  
  
    
  .
def
("get", static_cast<ValueType(nt::StructArraySubscriber<T, I>::*)(std::span<const T>) const>(
        &nt::StructArraySubscriber<T, I>::Get),
      py::arg("defaultValue"), release_gil(), py::doc(
    "Get the last published value.\n"
"If no value has been published or the value cannot be unpacked, returns the\n"
"passed defaultValue.\n"
"\n"
":param defaultValue: default value to return if no value has been published\n"
"\n"
":returns: value")
  )
  
  
  
    
  .
def
("getAtomic", static_cast<TimestampedValueType(nt::StructArraySubscriber<T, I>::*)() const>(
        &nt::StructArraySubscriber<T, I>::GetAtomic), release_gil(), py::doc(
    "Get the last published value along with its timestamp\n"
"If no value has been published or the value cannot be unpacked, returns the\n"
"stored default value and a timestamp of 0.\n"
"\n"
":returns: timestamped value")
  )
  
  
  
    
  .
def
("getAtomic", static_cast<TimestampedValueType(nt::StructArraySubscriber<T, I>::*)(std::span<const T>) const>(
        &nt::StructArraySubscriber<T, I>::GetAtomic),
      py::arg("defaultValue"), release_gil(), py::doc(
    "Get the last published value along with its timestamp.\n"
"If no value has been published or the value cannot be unpacked, returns the\n"
"passed defaultValue and a timestamp of 0.\n"
"\n"
":param defaultValue: default value to return if no value has been published\n"
"\n"
":returns: timestamped value")
  )
  
  
  
    
  .
def
("readQueue", &nt::StructArraySubscriber<T, I>::ReadQueue, release_gil(), py::doc(
    "Get an array of all valid value changes since the last call to ReadQueue.\n"
"Also provides a timestamp for each value. Values that cannot be unpacked\n"
"are dropped.\n"
"\n"
".. note:: The \"poll storage\" subscribe option can be used to set the queue\n"
"   depth.\n"
"\n"
":returns: Array of timestamped values; empty array if no valid new changes\n"
"          have been published since the previous call.")
  )
  
  
  
    
  .
def
("getTopic", &nt::StructArraySubscriber<T, I>::GetTopic, release_gil(), py::doc(
    "Get the corresponding topic.\n"
"\n"
":returns: Topic")
  )
  
  
  .def("close", [](nt::StructArraySubscriber<T, I> *self) {
  py::gil_scoped_release release;
  *self = nt::StructArraySubscriber<T, I>();
}, py::doc("Destroys the subscriber"))
.def("__enter__", [](nt::StructArraySubscriber<T, I> *self) {
  return self;
})
.def("__exit__", [](nt::StructArraySubscriber<T, I> *self, py::args args) {
  py::gil_scoped_release release;
  *self = nt::StructArraySubscriber<T, I>();
})
;

  



    if (set_doc) {
        cls_StructArraySubscriber.doc() = set_doc;
    }
    if (add_doc) {
        cls_StructArraySubscriber.doc() = py::cast<std::string>(cls_StructArraySubscriber.doc()) + add_doc;
    }

    
}

}; // struct bind_nt__StructArraySubscriber

}; // namespace rpygen
