

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>



#include <networktables\StructTopic.h>










#include <rpygen/nt__Publisher.hpp>



namespace rpygen {


using namespace nt;





template <typename T, typename I, typename CfgBase = EmptyTrampolineCfg>
struct PyTrampolineCfg_nt__StructPublisher :


    PyTrampolineCfg_nt__Publisher<

CfgBase
>

{
    using Base = nt::StructPublisher<T, I>;

    
    
};




template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
using PyTrampolineBase_nt__StructPublisher =

    PyTrampoline_nt__Publisher<

        PyTrampolineBase

        
        , PyTrampolineCfg
    >

;

template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
struct PyTrampoline_nt__StructPublisher : PyTrampolineBase_nt__StructPublisher<PyTrampolineBase, T, I, PyTrampolineCfg> {
    using PyTrampolineBase_nt__StructPublisher<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_nt__StructPublisher;






    using TopicType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TopicType;

    using ValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ValueType;

    using ParamType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ParamType;

    using TimestampedValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TimestampedValueType;






    
    

    
    

    

    
};

}; // namespace rpygen







#include <pybind11/stl.h>

#include <wpi_json_type_caster.h>

#include <wpystruct.h>


namespace rpygen {


using namespace nt;




template <typename T, typename I>
struct bind_nt__StructPublisher {

    

    
  
  
    using TopicType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TopicType;
  
    using ValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TimestampedValueType;
  

    

    
  using StructPublisher_Trampoline = rpygen::PyTrampoline_nt__StructPublisher<typename nt::StructPublisher<T, I>, T, I, typename rpygen::PyTrampolineCfg_nt__StructPublisher<T, I>>;
    static_assert(std::is_abstract<StructPublisher_Trampoline>::value == false, "nt::StructPublisher<T, I> " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename nt::StructPublisher<T, I>, StructPublisher_Trampoline, nt::Publisher> cls_StructPublisher;

    

    
    

    py::module &m;
    std::string clsName;

bind_nt__StructPublisher(py::module &m, const char * clsName) :
    
    cls_StructPublisher(m, clsName),

  

  
  
    m(m),
    clsName(clsName)
{
    
  

}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    

  cls_StructPublisher.doc() =
    "NetworkTables struct-encoded value publisher.";

  cls_StructPublisher
  
    
  .
def
("set", &nt::StructPublisher<T, I>::Set,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Publish a new value.\n"
"\n"
":param value: value to publish\n"
":param time:  timestamp; 0 indicates current NT time should be used")
  )
  
  
  
    
  .
def
("setDefault", &nt::StructPublisher<T, I>::SetDefault,
      py::arg("value"), release_gil(), py::doc(
    "Publish a default value.\n"
"On reconnect, a default value will never be used in preference to a\n"
"published value.\n"
"\n"
":param value: value")
  )
  
  
  
    
  .
def
("getTopic", &nt::StructPublisher<T, I>::GetTopic, release_gil(), py::doc(
    "Get the corresponding topic.\n"
"\n"
":returns: Topic")
  )
  
  
  .def("close", [](nt::StructPublisher<T, I> *self) {
  py::gil_scoped_release release;
  *self = nt::StructPublisher<T, I>();
}, py::doc("Destroys the publisher"))
.def("__enter__", [](nt::StructPublisher<T, I> *self) {
  return self;
})
.def("__exit__", [](nt::StructPublisher<T, I> *self, py::args args) {
  py::gil_scoped_release release;
  *self = nt::StructPublisher<T, I>();
})
;

  



    if (set_doc) {
        cls_StructPublisher.doc() = set_doc;
    }
    if (add_doc) {
        cls_StructPublisher.doc() = py::cast<std::string>(cls_StructPublisher.doc()) + add_doc;
    }

    
}

}; // struct bind_nt__StructPublisher

}; // namespace rpygen
